# Form3 API Client

## Client library

The library is a Go library to be use as so. For simplicity, it implements only limited functionality of the Account endpoints of Form3.

For accounts, it implements:
- `Create` a new bank account.
- `Fetch` an existing bank account.
- `Delete` an existing bank account.

## Library installation

Form3 client is a private repository so you cannot get it with the standard `go get ...`. The way to get it is downloading the repo and do the following steps in your project -the one that will use form3 client-

    go mod edit -replace "github.com/AdanJSuarez/form3"=[path-to-form3]

    Example: go mod edit -replace "github.com/AdanJSuarez/form3"=../form3 (if you downloaded in a folder side to side to your project)

You need to include it with `go mod tidy`

Then you need to import it in your module as any other dependency:

Example: `import "github.com/AdanJSuarez/form3/pkg/form3"`


## Library usage

After including the library in your project. You have `pkg` and `model` folder to your disposal. From the `pkg/form3` folder you need to call `form3.New()` as the entry point that returns a form3 object. After that you need to set the configuration. To do that you have two method:

- ConfigurationByValue(baseURL, accountPath): Passing the baseURL and accountPath as parameters
- ConfigurationByEnv(): Passing the baseURL and accountPath as environment variables.

For the second case you need to set `BASE_URL` and `ACCOUNT_PATH`

Note: You can find the values of both in the form3 API documentation.

After configuration, from the `pkg/account` folder you need to call `form3.Account()` that returns an account object and with it you can:

- account.Create(dataModel): Create an new account.
- account.Fetch(ID): Get an existent account.
- account.Delete(ID, version): Delete an existent account.

You can find the `DataModel` in the `model` folder.

For more information check Form3 API documentation.

## Run Tests
It requires docker and docker-compose. After the installation you need to type:

`docker-compose up`

## Tests
The description says the following: `Be well tested to the level you would expect in a commercial environment. Note that tests are expected to run against the provided fake account API.`

To fullfil this requirement, I implemented two groups, unit tests and integration tests. The integration test are the one that will run against
the provided fake account API.
- The unit tests are located in each module.
- The integration tests are in a specific folder called `integration`.

## Unit test coverage
Unfortunately the mocks reduce the total code coverage because they are included when coverage is calculated. Also there is a couple of scenarios not covered but they are two functions from the standard library. Other than that, the coverage is 100%

## Mocks

I created my unit tests using mocks generated by [Mockery](https://github.com/vektra/mockery).

Mocks are not committed to the repo, but the unit tests doesn't pass without them. In the `Dockerfile` I included a `RUN` forced to success, in a way that, if the unit tests fail for any reason, like failing to get Mockery, ***integration will run no matter what. This is not the best approach for production but, in this specific case, the requirement of the exercise is to see the tests running against the fake API (integration test), therefore I guaranteed that goal.***

If the Mockery installation fails, for any reason, when creating the image after `docker-compose up`, you still can to run the unit tests at `docker-compose up`:
- Get Mockery. There are different instructions depend on your system/preference [link](https://vektra.github.io/mockery/installation/#github-release)
- Generate the mocks based on the instruction. You would need to add the following Mockery flag: `--inpackage` to generate the mocks, only if the way you chose wasn't `go generate ./...`
- Run `docker-compose up`.

## Vendor

There is an open discussion of committing the dependencies or not to your repo. At the end, it depends of the team.
I saw in your client [repo](https://github.com/form3tech-oss/go-form3) you included it, therefore I took the same approach.

## Functions and Methods Documentation

I saw in your public repos that you don't usually document the function/methods, not even the public ones -mainly, some are- There are different approaches to function documentation, and like the other things, that is a team decision. I decided to document the public method of Form3 and Account, at least the public functionality, should be documented.

# Production readiness

## Versioning

For production we need to set the tag with the version to track the releases. We should follow the [semantic versioning](https://semver.org/)

## Configuration

This implementation of client library needs basically two parameters to run. The `Form3 URL` and the `account path`.
To set those parameters I implemented two different ways, as discussed before. For production ready, it should include a third case that could be read them from a file like `yaml` or `toml`. I decided to not implement that case because it will require either implement a parser for those files or include a third-party library that I am not allowed based on the instruction.

## Retry mechanism

The API documentation encourage us to use a [retry mechanism](https://www.api-docs.form3.tech/api/schemes/sepa-instant-credit-transfer/introduction/timeouts/retry-strategy) on failure. I implemented the exponential back-off retry algorithm set as pseudo-code in the Form3 API documentation, but it would be better to have the more sophisticate library as it is recommended in the documentation.

## Headers

The exercise requirements say to not implement authentication so I didn't do anything about it. For production ready we should include the Authentication header.

## Create

The instruction require to be simple and concise, so only implemented tha basic functionality for `Create`. One nice feature could be the possibility to pass parameters for creation instead of passing the `DataModel` object. The values that the user doesn't change often, also could be set through form3 configuration making it even simpler.
