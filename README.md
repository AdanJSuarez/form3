# Form3 Homework

Form3 homework.

Ref:

https://github.com/form3tech-oss/interview-accountapi

https://github.com/form3tech-oss/go-form3

## Client library

The library is a Go library to be use as so. For simplicity, it implements only limited functionality of the Account endpoints of Form3.

For accounts, it implements:
- `Create` a new bank account.
- `Fetch` a bank account.
- `Delete` a bank account.

A nice future feature we could include (not included) is to expose a C-shared API that would allow the use of this library from any other language than Go that can read C libraries, like Java, Python, Rust, C++, C, etc.

## Use

The library use an extension of the principle of [Hiding Information](https://en.wikipedia.org/wiki/Information_hiding) therefore you only can reach the functionality expose in form3.go that would be:
```go
    type Form3 struct
```

```go
    type Account interface {
        Create()
        Fetch()
        Delete()
    }
```

## Vendor

The eternal discussion of pushing the dependency to your repo. I saw in your client [repo](https://github.com/form3tech-oss/go-form3) you included it, so I took the same approach.
This, as everything in live, brings pros and cons.
This blog post talk about this... and he is a big fun btw :) [link](https://blog.boot.dev/golang/should-you-commit-the-vendor-folder-in-go/)


## Network
https://stackoverflow.com/questions/24319662/from-inside-of-a-docker-container-how-do-i-connect-to-the-localhost-of-the-mach

## Requirement for different method:
- Create: id, organisation_id, type(optional), attribute(base_currency, country)

## Mocks

I created my unit tests using mocks generated by [Mockery](https://github.com/vektra/mockery). There are two opposite approach related to mocks, there are teams that commit them to the repository and there are team that don't. There are pros and cons, so it is usually a matter of team decision. The ones in favour say that when committing them you eliminate the needs for generate them, that sometimes require external libraries/software. The others, consider that mocks are a tool to help with the tests, they should not be in the repo, so you generate them when you needed them.

I this case I didn't commit the mocks, but the unit tests doesn't pass without them. In the `Dockerfile` I included a `RUN` conditioned to success on the installation of Mockery, in a way that, if it fails, the unit tests will not run to avoid the failure of running all tests: unit and integration. The requirement of the exercise is to see the tests running against the fake API (integration test).

If the Mockery installation fails for any reason when creating the image after `docker-compose up`, you still can to run the unit tests at `docker-compose up`:
- Get Mockery. There are different instructions depend on your system/preference [link](https://vektra.github.io/mockery/installation/#github-release)
- Generate the mocks based on the instruction. You would need to add the following Mockery flag: `--inpackage` to generate the mocks, only if the way you chose wasn't `go generate ./...`
- Uncomment line 16 in Dockerfile. It has a note.
- Run `docker-compose up`.

## Configuration

This implementation of client library needs basically to parameters to run. The `Form3 URL` and the `account path`.
To set those parameters I implemented two different ways. One is setting them as parameters when instantiate form3 object and the other is read them from the environment variables. For production ready, it should include a third case that could be read them from a file like `yaml` or `toml`. I decided to not implement that case because it will require either implement a parser for those files or include a third-party library that I am not allowed based on the instruction.
